name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  release:
    types: [ published ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Test stage
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        run: go mod download

      - name: Generate code
        run: |
          make generate
          make manifests

      - name: Run linting
        run: make lint

      - name: Run unit tests
        run: make test

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        with:
          files: ./cover.out
          flags: unittests
          name: codecov-umbrella

  # E2E testing stage
  e2e-test:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'

      - name: Set up Kind
        uses: helm/kind-action@v1
        with:
          cluster_name: kind
          node_image: kindest/node:v1.29.2

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Generate manifests
        run: make manifests

      - name: Run e2e tests
        run: make test-e2e

  # Build stage
  build:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name != 'pull_request'
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'

      - name: Set up Skaffold
        run: |
          curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64
          chmod +x skaffold
          sudo mv skaffold /usr/local/bin

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate version information
        id: version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION=${{ github.event.release.tag_name }}
          else
            VERSION=$(scripts/version.sh version)
          fi
          COMMIT=$(scripts/version.sh commit)
          DATE=$(scripts/version.sh date)
          BUILD_BY="github-actions"
          GITHUB_AUTHOR="${{ github.actor }} <${{ github.event.pusher.email }}>"
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "commit=${COMMIT}" >> $GITHUB_OUTPUT
          echo "date=${DATE}" >> $GITHUB_OUTPUT
          echo "build_by=${BUILD_BY}" >> $GITHUB_OUTPUT
          echo "github_author=${GITHUB_AUTHOR}" >> $GITHUB_OUTPUT

      - name: Set image name
        id: image
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "image=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Generate manifests
        run: make manifests

      - name: Build and push image with Skaffold
        id: build
        env:
          KO_DOCKER_REPO: ${{ steps.image.outputs.image }}
          VERSION: ${{ steps.version.outputs.version }}
          COMMIT: ${{ steps.version.outputs.commit }}
          DATE: ${{ steps.version.outputs.date }}
          BUILD_BY: ${{ steps.version.outputs.build_by }}
          GITHUB_AUTHOR: ${{ steps.version.outputs.github_author }}
          IMAGE_NAME: ${{ steps.image.outputs.image }}
        run: |
          # Build with Skaffold using ci-cd profile and capture output
          BUILD_OUTPUT=$(skaffold build \
            --profile=ci-cd \
            --tag=${{ steps.version.outputs.version }} \
            --push \
            --output='{{range .}}{{.Tag}}@{{.Digest}}{{end}}')
          
          echo "Built image: ${BUILD_OUTPUT}"
          
          # Extract digest from the output
          DIGEST=$(echo ${BUILD_OUTPUT} | cut -d'@' -f2)
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          
          # Also output the full image reference
          echo "image_with_digest=${BUILD_OUTPUT}" >> $GITHUB_OUTPUT

  # Semantic versioning and release
  release:
    runs-on: ubuntu-latest
    needs: [test, e2e-test, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
      issues: write
      pull-requests: write
    outputs:
      released: ${{ steps.release.outputs.new_release_published }}
      version: ${{ steps.release.outputs.new_release_version }}
      tag: ${{ steps.release.outputs.new_release_git_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install semantic-release
        run: |
          npm install -g semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github

      - name: Release
        id: release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          semantic-release

  # Update Skaffold and deploy to dev
  deploy-dev:
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Skaffold
        run: |
          curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64
          chmod +x skaffold
          sudo mv skaffold /usr/local/bin

      - name: Deploy to dev environment
        env:
          KO_DOCKER_REPO: ${{ needs.build.outputs.image }}
          VERSION: ${{ needs.build.outputs.version }}
        run: |
          # Validate Skaffold configuration
          skaffold diagnose
          
          # Use the dev profile for deployment
          # This would typically deploy to a dev cluster
          echo "Would deploy to dev environment using:"
          echo "Image: ${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}"
          echo "Version: ${{ needs.build.outputs.version }}"
          
          # Example deployment command (uncomment when you have a dev cluster):
          # skaffold deploy --profile=dev --images=firedoor-operator=${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}

  # Deploy to production on release
  deploy-prod:
    runs-on: ubuntu-latest
    needs: [release]
    if: needs.release.outputs.released == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Skaffold
        run: |
          curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64
          chmod +x skaffold
          sudo mv skaffold /usr/local/bin

      - name: Deploy to production
        env:
          KO_DOCKER_REPO: ghcr.io/cloud-nimbus/firedoor
          VERSION: ${{ needs.release.outputs.version }}
        run: |
          # Validate Skaffold configuration
          skaffold diagnose
          
          # This would typically deploy to a production cluster
          echo "Would deploy to production using:"
          echo "Version: ${{ needs.release.outputs.version }}"
          echo "Tag: ${{ needs.release.outputs.tag }}"
          
          # Example deployment command (uncomment when you have a production cluster):
          # skaffold deploy --images=firedoor-operator=ghcr.io/cloud-nimbus/firedoor:${{ needs.release.outputs.version }}

  # Security scanning
  security:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name != 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
          
      - name: Run Trivy vulnerability scanner (Table format)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}
          format: 'table' 